<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>website_test</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {
  box-sizing: border-box;
}

#board {
    position: relative; 
    background-color: antiquewhite;
    border: 2px solid #444;
    margin: 20px;
}

.row {
    margin: 10px;
    display: flex;
    justify-content: center;
}

.ball {
    position: relative;
    width: 12%;
    padding-top: 12%;
    margin: 1%;
    border-radius: 50%;
    background-color: orange;
    border: 2px solid #444;
    user-select: none;
}

.ball .line {
    position: absolute;
    top: 50%;
    left: -12.5%;
    width: 125%;
    height: 3px;
    background-color: black;
    transform: translateY(-50%);
    display: none;  /* 默认隐藏 */
}

.ball.removed .line {
    display: block;  /* 被划过后显示横线 */
}


.draw-line {
    position: absolute;
    height: 3px;
    background-color: black;
    transform-origin: 0 50%;      /* 旋转基点设为 left top */
    pointer-events: none;       /* 不阻挡鼠标事件 */
}

.settingBoard {
    position: relative; 
    background-color: rgb(145, 145, 145);
    border: 2px solid #444;
    margin: 20px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: flex-start;;
    gap: 20px;
}

/* 开关整体 */
.reset-button {
    align-self: flex-end; /* 右对齐 */
    width: 30%;
    padding: 8px 12px;
    background-color: lightgreen;
    border: 2px solid #444;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;
}

.reset-button:hover {
    background-color: #66cc66;
}

.reset-button:active {
    transform: scale(0.95);
}

.toggle-group-firstplayer {
    display: flex;
    align-items: center;
    gap: 10px;
}

.toggle-label {
    font-size: 16px;
    transition: opacity 0.3s ease;
    user-select: none;
}

.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 24px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .slider {
    background-color: #8859da;
}

input:checked + .slider:before {
    transform: translateX(26px);
}

/* Disabled 整组 */
.toggle-group-firstplayer.disabled {
    opacity: 0.5;
    pointer-events: none;
}

.toggle-group-pvp {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px; /* 和下面按钮隔开一点 */
}

.toggle-group-pvp.disabled {
    opacity: 0.5;
    pointer-events: none;
}

</style>
<link rel="stylesheet" href="style.css">

</head>

<body>
<div class ="layout">
<!-- TopNav -->
<ul class="topnav">
    <li class="active"><a href="index.html">Home</a></li>
    <li class="dropdown">
        <a href="#news">News</a>
        <div class="dropdown-content">
            <a href="#local">Local</a>
            <a href="#international">International</a>
            <a href="#opinion">Opinion</a>
        </div>
    </li>
    <li><a href="#contact">Contact</a></li>
    <li><a href="#about">About</a></li>
</ul>
<div class="main-area">
    <!-- LeftNav -->
    <ul class ="leftnav">
        <li class="top">花活儿</li>
        <li ><a href="index.html">主页</a></li>
        <li ><a href="gacha.html">Gacha Simulation</a></li>
        <li><a href="testPage.html">Skill Learning</a></li>
        <li class="active highlight"><a href="nimGame.html">Nim Game</a></li>
        <li><a href="#4">4</a></li>
        <li><a href="#5">5</a></li>
        <li><a href="#6">6</a></li>
        <li><a href="#7">7</a></li>
        <li><a href="#8">8</a></li>
        <li><a href="#9">9</a></li>
        <li><a class="highlight" href="#10">10</a></li>
        <li><a href="#11">11</a></li>
        <li><a href="#12">12</a></li>
        <li><a href="#13">13</a></li>
        <li><a href="#14">14</a></li>
        <li><a href="#15">15</a></li>
        <li><a href="#16">16</a></li>
        <li><a href="#17">17</a></li>
        <li><a href="#18">18</a></li>
        <li><a href="#19">19</a></li>
        <li><a class="highlight" href="#20">20</a></li>
        <li><a href="#21">21</a></li>
        <li><a href="#22">22</a></li>
        <li><a href="#23">23</a></li>
        <li><a href="#24">24</a></li>
        <li><a href="#25">25</a></li>
        <li><a href="#26">26</a></li>
        <li><a href="#27">27</a></li>
        <li><a href="#28">28</a></li>
        <li><a href="#29">29</a></li>
        <li><a class="highlight" href="#30">30</a></li>
        <li><a href="#31">31</a></li>
        <li><a href="#32">32</a></li>
        <li><a href="#33">33</a></li>
        <li><a href="#34">34</a></li>
        <li><a href="#35">35</a></li>
        <li><a href="#36">36</a></li>
        <li><a href="#37">37</a></li>
        <li><a href="#38">38</a></li>
        <li><a href="#39">39</a></li>
        <li><a class="highlight" href="#40">40</a></li>
        <li><a href="#41">41</a></li>
        <li><a href="#42">42</a></li>
        <li><a href="#43">43</a></li>
        <li><a href="#44">44</a></li>
        <li><a href="#45">45</a></li>
        <li><a href="#46">46</a></li>
        <li><a href="#47">47</a></li>
        <li><a href="#48">48</a></li>
        <li><a href="#49">49</a></li>
        <li><a class="highlight" href="#50">50</a></li>
        <li><a href="#51">51</a></li>
        <li><a href="#52">52</a></li>
        <li><a href="#53">53</a></li>
        <li><a href="#54">54</a></li>
        <li><a href="#55">55</a></li>
        <li><a href="#56">56</a></li>
        <li><a href="#57">57</a></li>
        <li><a href="#58">58</a></li>
        <li><a href="#59">59</a></li>
        <li><a class="highlight" href="#60">60</a></li>
        <li><a href="#61">61</a></li>
        <li><a href="#62">62</a></li>
        <li><a href="#63">63</a></li>
        <li><a href="#64">64</a></li>
        <li><a href="#65">65</a></li>
        <li><a href="#66">66</a></li>
        <li><a href="#67">67</a></li>
        <li><a href="#68">68</a></li>
        <li><a href="#69">69</a></li>
        <li><a class="highlight" href="#70">70</a></li>
        <li><a href="#71">71</a></li>
        <li><a href="#72">72</a></li>
        <li><a href="#73">73</a></li>
        <li><a href="#74">74</a></li>
        <li><a href="#75">75</a></li>
        <li><a href="#76">76</a></li>
        <li><a href="#77">77</a></li>
        <li><a href="#78">78</a></li>
        <li><a href="#79">79</a></li>
        <li><a class="highlight" href="#80">80</a></li>
        <li><a href="#81">81</a></li>
        <li><a href="#82">82</a></li>
        <li><a href="#83">83</a></li>
        <li><a href="#84">84</a></li>
        <li><a href="#85">85</a></li>
        <li><a href="#86">86</a></li>
        <li><a href="#87">87</a></li>
        <li><a href="#88">88</a></li>
        <li><a href="#89">89</a></li>
        <li><a class="highlight" href="#90">90</a></li>
        <li><a href="#91">91</a></li>
        <li><a href="#92">92</a></li>
        <li><a href="#93">93</a></li>
        <li><a href="#94">94</a></li>
        <li><a href="#95">95</a></li>
        <li><a href="#96">96</a></li>
        <li><a href="#97">97</a></li>
        <li><a href="#98">98</a></li>
        <li><a href="#99">99</a></li>
        <li><a class="highlight" href="#100">100</a></li>
    </ul>

        <div class="main-content">
            <h2 style="color: red;text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;">欢迎来到MillerRXY的网站</h2>
            <h3 id="clock" style="color: #333;">现在的时间是：--:--:--</h3>
            <hr style="margin-top: 80px;">
            <h3>Nim游戏</h3>
            <p>这个游戏很简单</p>
            <p>规则是，一共有若干排小球</p>
            <p>你和你的对手轮流划球。每一次划球，你能划<b>一行中的</b>任意数量的球，</p>
            <p>简单来说就是你只能横着划，并且不能跨过已经划掉的球。</p>
            <p>划掉最后一个球的玩家为胜利者。</p>
            <div id="board">
                <div class="row" id="row-0"></div>
                <div class="row" id="row-1"></div>
                <div class="row" id="row-2"></div>
                <div class="row" id="row-3"></div>
                <div class="row" id="row-4"></div>
                <div class="row" id="row-5"></div>
                <div class="row" id="row-6"></div>
            </div>
            <div id="message" style="color: red; font-weight: bold; margin: 10px 20px;"></div>
            <div class="settingBoard">
            <button id="resetGameBtn" class="reset-button">重新开始游戏</button>
            <div class="toggle-group-pvp" id="pvpToggleGroup">
                <span class="toggle-label left" id="pvpLeftLabel">玩家 VS 电脑</span>
                <label class="switch" id="pvpSwitch">
                    <input type="checkbox" id="pvpToggle">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label right" id="pvpRightLabel">玩家 VS 玩家</span>
            </div>
            <div class="toggle-group-firstplayer" id="firstPlayerToggleGroup">
                <span class="toggle-label left" id="firstPlayerLeftLabel">玩家先手</span>
                <label class="switch" id="firstPlayerSwitch">
                    <input type="checkbox" id="firstPlayerToggle">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label right" id="firstPlayerRightLabel">AI先手</span>
            </div>
            <div style="margin-top: 10px;">
                <label for="rowCountInput" style="font-weight: bold; margin-right: 8px;">总共行数 (1~7)：</label>
                <input type="number" id="rowCountInput" value="3" min="1" max="7" style="width: 60px; text-align: center;">
            </div>
            <div id="rowSettings" style="margin-top: 10px;">
                <!-- 动态生成行输入框 -->
            </div>
            </div>
        </div>
    </div>
</div>

<script src="script.js"></script>
<script>
let hitBalls = new Set();
let drawEnabled = true;
let isDrawing = false;
let startX = 0, startY = 0;
let lineElem = null;
let aiFirst = false;
let enablePVP = false;
let aiRandomFirstMove = false;
const LINE_HEIGHT = 3;

class Ball {
    constructor(row, index, element) {
        this.row = row;
        this.index = index;
        this.removed = false;
        this.element = element;
    }

    remove() {
        this.removed = true;
        this.element.classList.add('removed'); // 显示横线
    }

    reset() {
        this.removed = false;
        this.element.classList.remove('removed'); // 隐藏横线
    }
}

const board = document.getElementById('board');

board.addEventListener('mousedown', (e) => {
    if (!drawEnabled) return;
    const rect = board.getBoundingClientRect();
    if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) {
        return;
    }

    isDrawing = true;
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;

    lineElem = document.createElement('div');
    lineElem.classList.add('draw-line');
    lineElem.style.left = `${startX}px`;
    lineElem.style.top = `${startY - LINE_HEIGHT/2}px`;
    lineElem.style.width = '0px';
    board.appendChild(lineElem);

    hitBalls.clear();
});

board.addEventListener('mousemove', (e) => {
    if (!isDrawing || !lineElem) return;

    const rect = board.getBoundingClientRect();
    let currentX = e.clientX - rect.left;
    let currentY = e.clientY - rect.top;

    if (currentX < 0) currentX = 0;
    if (currentX > rect.width) currentX = rect.width;
    if (currentY < 0) currentY = 0;
    if (currentY > rect.height) currentY = rect.height;

    const dx = currentX - startX;
    const dy = currentY - startY;
    const distance = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;

    lineElem.style.width = `${distance}px`;
    lineElem.style.transform = `rotate(${angle}deg)`;
});


function stopDrawing() {
    if (isDrawing && lineElem) {
        //用最终的线段做碰撞检测
        const lineRect = lineElem.getBoundingClientRect();
        balls.flat().forEach(ball => {
            if (ball.removed) return;
            const ballRect = ball.element.getBoundingClientRect();
            if (!(
                ballRect.left > lineRect.right ||
                ballRect.right < lineRect.left ||
                ballRect.top > lineRect.bottom ||
                ballRect.bottom < lineRect.top
            )) {
                hitBalls.add(ball);
            }
        });

        board.removeChild(lineElem);
        lineElem = null;

        const messageElem = document.getElementById('message');
        messageElem.textContent = '';

        //没有碰到任何球，直接退出
        if (hitBalls.size === 0) {
            hitBalls.clear();
            isDrawing = false;
            return;
        }

        //判断同一行
        const rows = new Set();
        hitBalls.forEach(ball => rows.add(ball.row));

        if (rows.size > 1) {
            messageElem.textContent = '你不能跨行划球！';
        } else {
            const row = [...rows][0];
            const indices = Array.from(hitBalls).map(ball => ball.index).sort((a, b) => a - b);
            const minIndex = indices[0];
            const maxIndex = indices[indices.length - 1];

            //检查是否跨过已划掉的球
            let hasGap = false;
            for (let i = minIndex; i <= maxIndex; i++) {
                const currentBall = balls[row][i];
                if (currentBall.removed && !hitBalls.has(currentBall)) {
                    hasGap = true;
                    break;
                }
            }

            if (hasGap) {
                messageElem.textContent = '你不能跨过已经划掉的球！';
            } else {
                hitBalls.forEach(ball => ball.remove());
                if(enablePVP == false){
                    //合法：把 hitBalls 中所有球标记为 removed
                    drawEnabled = false;
                    // 检查胜负
                    if (checkWin()) {
                        document.getElementById('message').textContent = '你赢了！！';
                    } else {
                        document.getElementById('message').textContent = '轮到AI回合';
                        drawEnabled = false;
                        setTimeout(() => {
                            executeAIMove(aiMove());
                        }, 1500);
                    }
                } else {
                    if (checkWin()) {
                        document.getElementById('message').textContent = '游戏结束！！';
                    }
                }
            }
        }

        hitBalls.clear();
    }
    isDrawing = false;
}

board.addEventListener('mouseup', stopDrawing);
board.addEventListener('mouseleave', stopDrawing);

const rowsData = [3, 5, 7, 0, 0, 0, 0,];
const balls = [];

function initGame() {
    const board = document.getElementById('board');
    rowsData.forEach((numBalls, row) => {
        const rowDiv = document.getElementById(`row-${row}`);
        const rowBalls = [];
        for (let i = 0; i < numBalls; i++) {
            const ballElem = document.createElement('div');
            ballElem.classList.add('ball');

            // 新增一条横线元素
            const lineElem = document.createElement('div');
            lineElem.classList.add('line');
            ballElem.appendChild(lineElem);

            rowDiv.appendChild(ballElem);

            const ball = new Ball(row, i, ballElem);
            rowBalls.push(ball);
        }
        balls.push(rowBalls);
    });
}

// ——————————————重重棋盘————————————————
function resetGame() {
    // 清空 balls 数组
    balls.length = 0;

    // 重新 build 每一行的 balls
    rowsData.forEach((numBalls, rowIndex) => {
        const rowDiv = document.getElementById(`row-${rowIndex}`);

        // 清空当前行的 DOM
        rowDiv.innerHTML = '';

        // 新建这一行的 balls
        const rowBalls = [];
        for (let i = 0; i < numBalls; i++) {
            const ballElem = document.createElement('div');
            ballElem.classList.add('ball');

            const lineElem = document.createElement('div');
            lineElem.classList.add('line');
            ballElem.appendChild(lineElem);

            rowDiv.appendChild(ballElem);

            const ball = new Ball(rowIndex, i, ballElem);
            rowBalls.push(ball);
        }

        balls.push(rowBalls);
    });

    // 其他参数复位
    drawEnabled = true;
    aiRandomFirstMove = false;
    hitBalls.clear();
    isDrawing = false;
    insideBoard = true;
    document.getElementById('message').textContent = '';

    // 如果AI先手...
    if (aiFirst && !enablePVP) {
        drawEnabled = false; 
        aiRandomFirstMove = true;
        executeAIMove(aiMove());
    }
}

//获取现阶段游戏元素的长度
let globalSegment = [];

function getSegmentLengths() {
    const segments = [];
    globalSegment = [];  // 每次调用先清空

    balls.forEach((rowBalls, rowIndex) => {
        let count = 0;
        let segmentStart = -1;

        rowBalls.forEach((ball, i) => {
            if (!ball.removed) {
                if (count === 0) {
                    segmentStart = i;  // 新段起点
                }
                count++;
            } else {
                if (count > 0) {
                    // 记录段
                    segments.push(count);
                    globalSegment.push({
                        row: rowIndex,
                        start: segmentStart,
                        length: count
                    });
                    count = 0;
                }
            }
        });

        // 行结束后检查最后一段
        if (count > 0) {
            segments.push(count);
            globalSegment.push({
                row: rowIndex,
                start: segmentStart,
                length: count
            });
        }
    });

    return segments;
}

//洗牌
function randomArray(x) {
    const arr = [];
    for (let i = 0; i < x; i++) {
        arr.push(i);
    }

    // 洗牌算法 - Fisher-Yates 洗牌
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];  // 交换
    }

    return arr;
}

/**
 * 计算 AI 的下一步走法
 * @returns {{
 *   row: number,         // 段所在的行号
 *   start: number,       // 段在该行中的起始索引
 *   length: number,      // 段的当前长度
 *   newValue: number,    // WM：该段减少到多少个球
 *   deleteCount: number, // AI 实际要删掉多少个球
 *   direction: string    // 'left' 或 'right'，随机决定从段起点或段末端开始删
 * }}
 */

function aiMove() {
    const segments = getSegmentLengths();
    const lengthOfSegments = segments.length;
    const randomIndex = randomArray(lengthOfSegments);

    // --- 如果是 AI 的首手，并且满足 95% 概率，就随机选一行一列划球 ---
    if (aiRandomFirstMove) {
        aiRandomFirstMove = false;  // 只在首手使用一次

        if (Math.random() < 0.95) {
            // randomIndex 是一个 [0, 1, 2, … lengthOfSegments-1] 的乱序数组
            for (let idx of randomIndex) {
                const segLen = segments[idx];
                if (segLen === 0) continue;  // 如果该段长度为 0，就跳到下一个

                // 找到对应段信息
                const segmentInfo = globalSegment[idx];
                const { row, start, length } = segmentInfo;

                // 随机选一个要删除的数量：1 ~ segLen
                const deleteCount = Math.floor(Math.random() * segLen) + 1;

                // 随机选“从左删”还是“从右删”
                const direction = Math.random() < 0.5 ? 'left' : 'right';

                // 构造并返回“随机首手”操作方案
                return {
                    row: row,
                    start: start,
                    length: length,
                    newValue: segLen - deleteCount,
                    deleteCount: deleteCount,
                    direction: direction
                };
            }
            // 上面的循环理论上一定能 return，一般不会走到这里。
        }
        // 如果 Math.random() >= 0.9，那就直接走下面的最优算法
    }

    // --- 算法 ---
    for (let idx of randomIndex) {
        const segLen = segments[idx];
        if (segLen === 0) continue;

        const copy = [...segments];
        copy.splice(idx, 1);

        for (let j = segLen - 1; j >= 0; j--) {
            let xorSum = j;
            for (let v of copy) {
                xorSum ^= v;
            }

            if (xorSum === 0) {
                // 查找对应段的 row + start
                const segmentInfo = globalSegment[idx];

                // 左/右方向随机
                const direction = Math.random() < 0.5 ? 'left' : 'right';

                // 返回操作方案
                return {
                    row: segmentInfo.row,
                    start: segmentInfo.start,
                    length: segmentInfo.length,
                    newValue: j,
                    deleteCount: segLen - j,
                    direction: direction
                };
            }
        }
    }

    // 如果没找到合法方案，兜底策略
    const randomIdx = Math.floor(Math.random() * lengthOfSegments);
    const segmentInfo = globalSegment[randomIdx];
    const segLen = segments[randomIdx];

    const deleteCount = Math.floor(Math.random() * segLen) + 1;

    //console.log('[AI兜底策略] 随机选择 row:', segmentInfo.row, ' start:', segmentInfo.start, ' 删除:', deleteCount);

    return {
        row: segmentInfo.row,
        start: segmentInfo.start,
        length: segmentInfo.length,
        newValue: segLen - deleteCount,
        deleteCount: deleteCount,
        direction: Math.random() < 0.5 ? 'left' : 'right'
    };
}

function executeAIMove(move) {
    const rowBalls = balls[move.row];

    // 根据 move.direction，先算出“动画起点球索引”和“动画终点球索引”
    let animStartIndex, animEndIndex;
    if (move.direction === 'left') {
        // 从段起点往右删 deleteCount 个 → 动画从最左被删球 到 最右被删球
        animStartIndex = move.start;
        animEndIndex   = move.start + move.deleteCount - 1;
    } else {
        // 从段末端往左删 deleteCount 个 → 动画从最右被删球 到 最左被删球
        const segmentEnd = move.start + move.length - 1;
        animStartIndex = segmentEnd;
        animEndIndex   = segmentEnd - (move.deleteCount - 1);
    }

    // 找到对应的 DOMRect
    const startBall = rowBalls[animStartIndex];
    const endBall   = rowBalls[animEndIndex];

    const boardRect = board.getBoundingClientRect();
    const startRect = startBall.element.getBoundingClientRect();
    const endRect   = endBall.element.getBoundingClientRect();

    // 计算从球的左外部到右外部的“动画起点”和“终点”坐标
    //      这里偏移 4px，让线从球左/右外部开始
    const startX = startRect.left + (move.direction === 'left' 
                     ? -4                                     // 左外部
                     : startRect.width + 4) - boardRect.left; // 右外部
    const startY = startRect.top + startRect.height / 2 - boardRect.top;

    const endX = endRect.left + (move.direction === 'left'
                   ? endRect.width + 4                     // 删向右时的终点要在球右外部
                   : -4) - boardRect.left;                  // 删向左时的终点要在球左外部
    const endY = endRect.top + endRect.height / 2 - boardRect.top;

    // 计算角度和距离
    const dx = endX - startX;
    const dy = endY - startY;
    const distance = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;

    // 创建 draw-line 并插入
    const lineElem = document.createElement('div');
    lineElem.classList.add('draw-line');
    lineElem.style.left = `${startX}px`;
    lineElem.style.top = `${startY - LINE_HEIGHT / 2}px`;
    lineElem.style.width = '0px';
    lineElem.style.transform = `rotate(${angle}deg)`;
    board.appendChild(lineElem);

    // 播放动画：从 0 → distance
    const duration = 300;
    const startTime = performance.now();

    function animate(time) {
        const t = Math.min((time - startTime) / duration, 1);
        lineElem.style.width = `${distance * t}px`;

        if (t < 1) {
            requestAnimationFrame(animate);
        } else {
            // 动画结束，移除线条，并真正删除那些球
            board.removeChild(lineElem);

            if (move.direction === 'left') {
                // 从左到右删
                for (let i = 0; i < move.deleteCount; i++) {
                    const idx = move.start + i;
                    if (idx < rowBalls.length && !rowBalls[idx].removed) {
                        rowBalls[idx].remove();
                    }
                }
            } else {
                // 从右到左删
                const segmentEnd = move.start + move.length - 1;
                for (let i = 0; i < move.deleteCount; i++) {
                    const idx = segmentEnd - i;
                    if (idx >= 0 && !rowBalls[idx].removed) {
                        rowBalls[idx].remove();
                    }
                }
            }

            // 胜负判断
            if (checkWin()) {
                document.getElementById('message').textContent = 'AI 胜利！';
                drawEnabled = false;
            } else {
                document.getElementById('message').textContent = '轮到玩家回合';
                drawEnabled = true;
            }
        }
    }

    requestAnimationFrame(animate);
}

function checkWin() {
    // 如果所有球都被 removed，返回 true（游戏结束）
    return balls.flat().every(ball => ball.removed);
}

const firstPlayerToggle = document.getElementById('firstPlayerToggle');
const firstPlayerLeftLabel = document.getElementById('firstPlayerLeftLabel');
const firstPlayerRightLabel = document.getElementById('firstPlayerRightLabel');
const firstPlayerToggleGroup = document.getElementById('firstPlayerToggleGroup');

let firstPlayerToggleEnabled = true;  // 是否允许切换

function updateFirstPlayerToggleUI() {
    if (aiFirst) {
        firstPlayerLeftLabel.style.opacity = '0.5';
        firstPlayerRightLabel.style.opacity = '1';
    } else {
        firstPlayerLeftLabel.style.opacity = '1';
        firstPlayerRightLabel.style.opacity = '0.5';
    }
}

firstPlayerToggle.addEventListener('change', () => {
    if (!firstPlayerToggleEnabled) return;

    aiFirst = firstPlayerToggle.checked;
    updateFirstPlayerToggleUI();
});

// 初始化状态
updateFirstPlayerToggleUI();

// 禁用切换
function disableFirstPlayerToggle() {
    firstPlayerToggleEnabled = false;
    firstPlayerToggleGroup.classList.add('disabled');
}

// 启用切换
function enableFirstPlayerToggle() {
    firstPlayerToggleEnabled = true;
    firstPlayerToggleGroup.classList.remove('disabled');
}

const pvpToggle = document.getElementById('pvpToggle');
const pvpLeftLabel = document.getElementById('pvpLeftLabel');
const pvpRightLabel = document.getElementById('pvpRightLabel');
const pvpToggleGroup = document.getElementById('pvpToggleGroup');

// 更新 UI
function updatePvpToggleUI() {
    if (enablePVP) {
        pvpLeftLabel.style.opacity = '0.5';
        pvpLeftLabel.style.fontWeight = 'normal';
        pvpRightLabel.style.opacity = '1';
        pvpRightLabel.style.fontWeight = 'bold';
        disableFirstPlayerToggle();
    } else {
        pvpLeftLabel.style.opacity = '1';
        pvpLeftLabel.style.fontWeight = 'bold';
        pvpRightLabel.style.opacity = '0.5';
        pvpRightLabel.style.fontWeight = 'normal';
        enableFirstPlayerToggle();
    }
}

// 事件监听
pvpToggle.addEventListener('change', () => {
    enablePVP = pvpToggle.checked;
    updatePvpToggleUI();
});

//重置游戏
const resetGameBtn = document.getElementById('resetGameBtn');
resetGameBtn.addEventListener('click', resetGame);

updatePvpToggleUI();

// ——————————————初始化——————————————
initGame();
// —————————————————————————————————

const rowCountInput = document.getElementById('rowCountInput');

function updateRowSettingsUI() {
    const rowSettingsDiv = document.getElementById('rowSettings');
    rowSettingsDiv.innerHTML = '';  // 清空之前的

    const numRows = parseInt(rowCountInput.value);

    for (let row = 0; row < numRows; row++) {
        // 创建一个行容器
        const rowDiv = document.createElement('div');
        rowDiv.style.display = 'flex';
        rowDiv.style.alignItems = 'center';
        rowDiv.style.marginBottom = '5px';
        rowDiv.style.gap = '8px';

        // 行标签
        const label = document.createElement('label');
        label.textContent = `第 ${row + 1} 行小球数：`;
        label.style.fontWeight = 'bold';

        // 行输入框
        const input = document.createElement('input');
        input.type = 'number';
        input.min = 0;
        input.max = 15;  // 自定义你想允许的最大值
        input.style.width = '60px';
        input.style.textAlign = 'center';

        // 设置默认值
        if (rowsData[row] === 0) {
            if (row === 0) {
                rowsData[row] = 3;
            } else if (row === 1) {
                rowsData[row] = 5;
            } else {
                rowsData[row] = 7;
            }
        }

        input.value = rowsData[row];

        // 输入框监听
        input.addEventListener('input', () => {
            let value = parseInt(input.value);
            if (isNaN(value) || value < 0) {
                value = 0;
                input.value = 0;
            } else if (value > 15) {
                value = 15;
                input.value = 15;
            }

            rowsData[row] = value;
            resetGame();
        });

        // 组装
        rowDiv.appendChild(label);
        rowDiv.appendChild(input);

        // 添加到 settings 区域
        rowSettingsDiv.appendChild(rowDiv);
    }
}

rowCountInput.addEventListener('input', () => {
    let value = rowCountInput.value.trim();

    if (value === '' || isNaN(value)) {
        rowCountInput.value = 3;
        value = 3;
    }

    let numRows = parseInt(value);

    if (numRows < 1) {
        numRows = 1;
        rowCountInput.value = 1;
    } else if (numRows > 7) {
        numRows = 7;
        rowCountInput.value = 7;
    }

    // 更新 rowsData
    for (let i = 0; i < rowsData.length; i++) {
        if (i < numRows) {
            if (typeof rowsData[i] === 'undefined') {
                rowsData[i] = 0;
            }
        } else {
            rowsData[i] = 0;
        }
    }

    // 重新初始化棋盘
    resetGame();

    // 更新每行输入框
    updateRowSettingsUI();
});

function handleRowCountChange() {
    let value = rowCountInput.value.trim();

    if (value === '' || isNaN(value)) {
        rowCountInput.value = 3;
        value = 3;
    }

    let numRows = parseInt(value);

    if (numRows < 1) {
        numRows = 1;
        rowCountInput.value = 1;
    } else if (numRows > 7) {
        numRows = 7;
        rowCountInput.value = 7;
    }

    // 更新 rowsData
    for (let i = 0; i < rowsData.length; i++) {
        if (i < numRows) {
            if (typeof rowsData[i] === 'undefined') {
                rowsData[i] = 0;
            }
        } else {
            rowsData[i] = 0;
        }
    }

    // 重新初始化棋盘
    resetGame();

    // 更新每行输入框
    updateRowSettingsUI();
}

rowCountInput.addEventListener('input', handleRowCountChange);
updateRowSettingsUI();


</script>
</body>

</html>
